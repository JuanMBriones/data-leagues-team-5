hist_bootstrap <- ggplot() +
geom_histogram(aes(x = medias), color="black") +
geom_vline(xintercept = media_muestral, size=1, color="darkred") +
ylab("Frecuencia") +
ggtitle("Histograma de las medias")
hist_bootstrap
desv_est <- sqrt(sum((medias - media_muestral) ** 2) / length(medias))
prueba_dos_colas(medias, mu=1)
prueba_dos_colas <- function(ma_cociente, mu = 1){
n <- length(ma_cociente)
# Prueba
estadistico <- (mean(ma_cociente, na.rm = TRUE) - mu)/(sd(ma_cociente, na.rm = TRUE)/n**(1/2))
pvalue <- pnorm(abs(estadistico), lower.tail = FALSE)*2
return(pvalue)
}
prueba_dos_colas(medias, mu=1)
t.test(medias)
norm.test(medias)
setwd("../Sesion5/Files/")
nyc <- read.csv("nyc.csv", header = TRUE)
tail(nyc, 2)
dim(nyc)
attach(nyc)
pairs(~ Price + Food + Decor + Service, data = nyc, gap = 0.4, cex.labels = 1.5)
cor(nyc)
cor(Price, Food)
cor(Price, Decor)
cor(~)
m1 <- lm(Price ~ Food + Decor + Service + East)
summary(m1)
summary(nyc)
m2 <- lm(Price ~ Food + Decor + East)
summary(m2)
m2 <- update(m1, ~.-Service)
summary(m2)
mfull <- lm(Price ~ Food + Decor + Service + East +
Food:East + Decor:East + Service:East)
summary(mfull)
anova(m2,mfull)
summary(m2)
plot(m2$fitted.values, Price, xlab = "Valores ajustados", ylab = "Price")
abline(lsfit(m2$fitted.values, Price))
pairs(~ Food + Decor, data = nyc, gap = 0.4, cex.labels = 1.5)
StanRes2 <- rstandard(m2)
par(mfrow = c(2, 2))
plot(Food, StanRes2, ylab = "Residuales Estandarizados")
plot(Decor, StanRes2, ylab = "Residuales Estandarizados")
plot(East, StanRes2, ylab = "Residuales Estandarizados")
qqnorm(StanRes2)
qqline(StanRes2)
qqnorm(StanRes2)
qqline(StanRes2)
hist(StanRes2)
shapiro.test(StanRes2)
library(dplyr)
library(e1071)
library(ggplot2)
library(ISLR)
?Default
data <- read.csv("https://raw.githubusercontent.com/beduExpert/Programacion-R-Santander-2021/main/Sesion-05/Reto-01/advertising.csv")
tail(data, 2)
dim(data)
attach(data)
pairs(~ Sales + Newspaper + Radio + TV, data = data, gap = 0.4, cex.labels = 1.5) # ~ todas contra todas
m1 <- lm(Sales ~ Newspaper + Radio + TV)
summary(m1)
m2 <- lm(Sales ~ Radio + TV)
summary(m2)
plot(m2$fitted.values, Price, xlab = "Valores ajustados", ylab = "Sales")
plot(m2$fitted.values, Sales, xlab = "Valores ajustados", ylab = "Sales")
abline(lsfit(m2$fitted.values, Sales))
plot(m2$fitted.values, Sales, xlab = "Valores ajustados", ylab = "Sales")
abline(lsfit(m2$fitted.values, Sales))
plot(m2$fitted.values, Sales, xlab = "Valores ajustados", ylab = "Sales")
abline(lsfit(m2$fitted.values, Sales))
summary(m2)
plot(m2$fitted.values, Sales, xlab = "Valores ajustados", ylab = "Sales")
plot(m2$fitted.values, Sales, xlab = "Valores ajustados", ylab = "Sales")
abline(lsfit(m2$fitted.values, Sales))
StanRes2 <- rstandard(m2)
par(mfrow = c(2, 2))
plot(Radio, StanRes2, ylab = "Residuales Estandarizados")
plot(TV, StanRes2, ylab = "Residuales Estandarizados")
qqnorm(StanRes2)
qqline(StanRes2)
hist(StanRes2)
detach(nyc)
library(dplyr)
library(e1071)
library(ggplot2)
library(ISLR)
head(Default)
tail(Default)
dim(Default)
str(Default)
ggplot(Default, aes(x = balance, y = income, colour = default)) +
geom_point() + facet_wrap('student') +
theme_grey() + ggtitle("Datos Default")
set.seed(2020)
train = sample(nrow(Default),
round(nrow(Default)/2))
tail(Default[train, ])
ggplot(Default[train, ],
aes(x = balance, y = income, colour = default)) +
geom_point() + facet_wrap('student') +
theme_dark() + ggtitle("Conjunto de entrenamiento")
ggplot(Default[-train, ],
aes(x = balance, y = income, colour = default)) +
geom_point() + facet_wrap('student') +
theme_light() + ggtitle("Conjunto de prueba")
tune.rad = tune(svm, default~., data = Default[train,],
kernel = "radial",
ranges = list(
cost = c(0.1, 1, 10, 100, 1000),
gamma = seq(0.01, 10, 0.5)
)
)
shiny::runApp('~/BEDU/PostWork-8')
dir()
setwd("Postwork/")
ls
dir()
setwd("Files/")
library(dplyr)
library(fbRanks)
partidos_17 <- read.csv("esp18.csv")
partidos_18 <- read.csv("esp19.csv")
partidos_19 <- read.csv("esp20.csv")
partidos_17 <- select(partidos_17,
c("Date", "HomeTeam", "FTHG", "AwayTeam", "FTAG"))
partidos_18 <- select(partidos_18,
c("Date", "HomeTeam", "FTHG", "AwayTeam", "FTAG"))
partidos_19 <- select(partidos_19,
c("Date", "HomeTeam", "FTHG", "AwayTeam", "FTAG"))
partidos_17 <- mutate(partidos_17,
Date=as.Date(Date, "%d/%m/%y"))
partidos_18 <- mutate(partidos_18,
Date=as.Date(Date, "%d/%m/%y"))
partidos_19 <- mutate(partidos_19,
Date=as.Date(Date, "%d/%m/%y"))
SmallData <- do.call(rbind, list(partidos_17,
partidos_18,
partidos_19))
SmallData <- rename(SmallData, c("date"="Date",
"home.team" = "HomeTeam",
"home.score"="FTHG",
"away.team"="AwayTeam",
"away.score"="FTAG"))
write.csv(SmallData, "soccer.csv", row.names = FALSE)
listasoccer <- create.fbRanks.dataframes(scores.file = "soccer.csv")
anotaciones <- listasoccer[["scores"]]
anotaciones <- rank.teams(anotaciones)
equipos <- listasoccer[["teams"]]
equipos <- rank.teams(scores = listasoccer[["scores"]],
teams = equipos)
fecha <- unique(as.Date(listasoccer[["scores"]]$date))
fecha
n <- length(fecha)
n
ranking <- rank.teams(scores = listasoccer[["scores"]],
teams = listasoccer[["teams"]],
max.date = fecha[n - 1],
min.date = fecha[1])
predict(object = ranking, date = fecha[n])
str(partidos_17)
# Con la función read.csv() se guardan los campos y registros de los archivos
# .csv seleccionados y los almacena en objetos de tipo data.frame.
partidos_17 <- read.csv("esp18.csv")
str(partidos_17)
list(partidos_17,
partidos_18,
partidos_19)
listasoccer
setwd("Files/")
library(dplyr)
library(fbRanks)
# Con la función read.csv() se guardan los campos y registros de los archivos
# .csv seleccionados y los almacena en objetos de tipo data.frame.
partidos_17 <- read.csv("esp18.csv")
partidos_18 <- read.csv("esp19.csv")
partidos_19 <- read.csv("esp20.csv")
# La función select() permite seleccionar los campos deseados de un data.frame.
partidos_17 <- select(partidos_17,
c("Date", "HomeTeam", "FTHG", "AwayTeam", "FTAG"))
partidos_18 <- select(partidos_18,
c("Date", "HomeTeam", "FTHG", "AwayTeam", "FTAG"))
partidos_19 <- select(partidos_19,
c("Date", "HomeTeam", "FTHG", "AwayTeam", "FTAG"))
# La función mutate cambia el formato de dato del campo que se deseé. En este
# caso el campo "date".
partidos_17 <- mutate(partidos_17,
Date=as.Date(Date, "%d/%m/%y"))
partidos_18 <- mutate(partidos_18,
Date=as.Date(Date, "%d/%m/%y"))
partidos_19 <- mutate(partidos_19,
Date=as.Date(Date, "%d/%m/%y"))
# La función do.call() compuesta con las funciones rbind() y list(), une los
# tres dataframes por campo y en orden ascendente en en campo de la fecha.
SmallData <- do.call(rbind, list(partidos_17,
partidos_18,
partidos_19))
# La función rename() permite cambiar el nombre de los campos seleccionados.
SmallData <- rename(SmallData, c("date"="Date",
"home.team" = "HomeTeam",
"home.score"="FTHG",
"away.team"="AwayTeam",
"away.score"="FTAG"))
# Se guarda un archivo .csv del dataframe "SmallData"
write.csv(SmallData, "soccer.csv", row.names = FALSE)
# Se crean
listasoccer <- create.fbRanks.dataframes(scores.file = "soccer.csv")
listasoccer
anotaciones <- listasoccer[["scores"]]
anotaciones <- rank.teams(anotaciones)
equipos <- listasoccer[["teams"]]
equipos <- rank.teams(scores = listasoccer[["scores"]],
teams = equipos)
fecha <- unique(as.Date(listasoccer[["scores"]]$date))
fecha
n <- length(fecha)
n
ranking <- rank.teams(scores = listasoccer[["scores"]],
teams = listasoccer[["teams"]],
max.date = fecha[n - 1],
min.date = fecha[1])
predict(object = ranking, date = fecha[n])
str(listasoccer)
anotaciones <- listasoccer[["scores"]]
anotaciones <- rank.teams(anotaciones)
equipos <- listasoccer[["teams"]]
equipos <- rank.teams(scores = listasoccer[["scores"]],
teams = equipos)
predict(object = ranking, date = fecha[n])
anotaciones
listasoccer
SmallData
View(SmallData)
# Se crean los dataframes requeridos con la función create.fbRanks.dataframes()
listasoccer <- create.fbRanks.dataframes(scores.file = "soccer.csv")
# Se guarda el campo "scores" dentro de la variable anotaciones.
anotaciones <- listasoccer[["scores"]]
anotaciones <- rank.teams(anotaciones)
equipos <- listasoccer[["teams"]]
equipos <- rank.teams(scores = listasoccer[["scores"]],
teams = equipos)
# Se guarda el campo "teams" dentro de la variable equipos.
equipos <- listasoccer[["teams"]]
# La función rank.teams() clasifica a los equipos según tres parámetros, total,
# ataque y defensa
equipos <- rank.teams(scores = listasoccer[["scores"]],
teams = equipos)
ranking
predict(object = ranking, date = fecha[n])
predict(object = ranking, date = fecha[n])
tail(SmallData)
library(dplyr)
library(fbRanks)
# Con la función read.csv() se guardan los campos y registros de los archivos
# .csv seleccionados y los almacena en objetos de tipo data.frame.
partidos_17 <- read.csv("esp18.csv")
partidos_18 <- read.csv("esp19.csv")
partidos_19 <- read.csv("esp20.csv")
# La función select() permite seleccionar los campos deseados de un data.frame.
partidos_17 <- select(partidos_17,
c("Date", "HomeTeam", "FTHG", "AwayTeam", "FTAG"))
partidos_18 <- select(partidos_18,
c("Date", "HomeTeam", "FTHG", "AwayTeam", "FTAG"))
partidos_19 <- select(partidos_19,
c("Date", "HomeTeam", "FTHG", "AwayTeam", "FTAG"))
# La función mutate cambia el formato de dato del campo que se deseé. En este
# caso el campo "date".
partidos_17 <- mutate(partidos_17,
Date=as.Date(Date, "%d/%m/%y"))
partidos_18 <- mutate(partidos_18,
Date=as.Date(Date, "%d/%m/%y"))
partidos_19 <- mutate(partidos_19,
Date=as.Date(Date, "%d/%m/%y"))
# La función do.call() compuesta con las funciones rbind() y list(), une los
# tres dataframes por campo y en orden ascendente en en campo de la fecha.
SmallData <- do.call(rbind, list(partidos_17,
partidos_18,
partidos_19))
# La función rename() permite cambiar el nombre de los campos seleccionados.
SmallData <- rename(SmallData, c("date"="Date",
"home.team" = "HomeTeam",
"home.score"="FTHG",
"away.team"="AwayTeam",
"away.score"="FTAG"))
# Se guarda un archivo .csv del dataframe "SmallData"
write.csv(SmallData, "soccer.csv", row.names = FALSE)
# Se crean los dataframes requeridos con la función create.fbRanks.dataframes()
listasoccer <- create.fbRanks.dataframes(scores.file = "soccer.csv")
# Se guarda el campo "scores" dentro de la variable anotaciones.
anotaciones <- listasoccer[["scores"]]
# La función rank.teams() clasifica a los equipos según tres parámetros, total,
# ataque y defensa
anotaciones <- rank.teams(anotaciones)
# Se guarda el campo "teams" dentro de la variable equipos.
equipos <- listasoccer[["teams"]]
# La función rank.teams() clasifica a los equipos según tres parámetros, total,
# ataque y defensa
equipos <- rank.teams(scores = listasoccer[["scores"]],
teams = equipos)
# La función unique nos permite obtener los datos no repetidos de un campo, en
# este caso "date" dentro de la
fecha <- unique(as.Date(listasoccer[["scores"]]$date))
fecha
# Se obtiene el número de datos en "fecha".
n <- length(fecha)
n
# Se obtiene el ranking de las fechas del dataframe que inicialmente se tenía,
# es decir: 2017-08-18 al 2020-12-22.
ranking <- rank.teams(scores = listasoccer[["scores"]],
teams = listasoccer[["teams"]],
max.date = fecha[n - 1],
min.date = fecha[1])
predict(object = ranking, date = fecha[n])
tail(SmallData)
setwd("Files/")
dir()
setwd("c:/Users/eherr/OneDrive/Documents/BEDU/data-leagues-team-5/Postwork/Files/")
setwd("Files/")
setwd("c:/Users/eherr/OneDrive/Documents/BEDU/data-leagues-team-5/Postwork/")
setwd("Files/")
library(dplyr)
library(fbRanks)
# Con la función read.csv() se guardan los campos y registros de los archivos
# .csv seleccionados y los almacena en objetos de tipo data.frame.
partidos_17 <- read.csv("esp18.csv")
partidos_18 <- read.csv("esp19.csv")
partidos_19 <- read.csv("esp20.csv")
# La función select() permite seleccionar los campos deseados de un data.frame.
partidos_17 <- select(partidos_17,
c("Date", "HomeTeam", "FTHG", "AwayTeam", "FTAG"))
partidos_18 <- select(partidos_18,
c("Date", "HomeTeam", "FTHG", "AwayTeam", "FTAG"))
partidos_19 <- select(partidos_19,
c("Date", "HomeTeam", "FTHG", "AwayTeam", "FTAG"))
# La función mutate cambia el formato de dato del campo que se deseé. En este
# caso el campo "date".
partidos_17 <- mutate(partidos_17,
Date=as.Date(Date, "%d/%m/%y"))
partidos_18 <- mutate(partidos_18,
Date=as.Date(Date, "%d/%m/%y"))
partidos_19 <- mutate(partidos_19,
Date=as.Date(Date, "%d/%m/%y"))
# La función do.call() compuesta con las funciones rbind() y list(), une los
# tres dataframes por campo y en orden ascendente en en campo de la fecha.
SmallData <- do.call(rbind, list(partidos_17,
partidos_18,
partidos_19))
# La función rename() permite cambiar el nombre de los campos seleccionados.
SmallData <- rename(SmallData, c("date"="Date",
"home.team" = "HomeTeam",
"home.score"="FTHG",
"away.team"="AwayTeam",
"away.score"="FTAG"))
# Se guarda un archivo .csv del dataframe "SmallData"
write.csv(SmallData, "soccer.csv", row.names = FALSE)
# Se crean los dataframes requeridos con la función create.fbRanks.dataframes()
listasoccer <- create.fbRanks.dataframes(scores.file = "soccer.csv")
# Se guarda el campo "scores" dentro de la variable anotaciones.
anotaciones <- listasoccer[["scores"]]
# La función rank.teams() clasifica a los equipos según tres parámetros, total,
# ataque y defensa
anotaciones <- rank.teams(anotaciones)
# Se guarda el campo "teams" dentro de la variable equipos.
equipos <- listasoccer[["teams"]]
# La función rank.teams() clasifica a los equipos según tres parámetros, total,
# ataque y defensa
equipos <- rank.teams(scores = listasoccer[["scores"]],
teams = equipos)
# La función unique nos permite obtener los datos no repetidos de un campo, en
# este caso "date" dentro de la
fecha <- unique(as.Date(listasoccer[["scores"]]$date))
fecha
# Se obtiene el número de datos en "fecha".
n <- length(fecha)
n
# Se obtiene el ranking de las fechas del dataframe que inicialmente se tenía,
# es decir: 2017-08-18 al 2020-12-22.
ranking <- rank.teams(scores = listasoccer[["scores"]],
teams = listasoccer[["teams"]],
max.date = fecha[n - 1],
min.date = fecha[1])
predict(object = ranking, date = fecha[n])
tail(SmallData)
library(dplyr)
library(fbRanks)
# Con la función read.csv() se guardan los campos y registros de los archivos
# .csv seleccionados y los almacena en objetos de tipo data.frame.
partidos_17 <- read.csv("esp18.csv")
# Con la función read.csv() se guardan los campos y registros de los archivos
# .csv seleccionados y los almacena en objetos de tipo data.frame.
partidos_17 <- read.csv("esp18.csv")
setwd("c:/Users/eherr/OneDrive/Documents/BEDU/data-leagues-team-5/Postwork/")
setwd("Files/")
dir()
dir()
# Con la función read.csv() se guardan los campos y registros de los archivos
# .csv seleccionados y los almacena en objetos de tipo data.frame.
partidos_17 <- read.csv("esp18.csv")
partidos_18 <- read.csv("esp19.csv")
partidos_19 <- read.csv("esp20.csv")
# La función select() permite seleccionar los campos deseados de un data.frame.
partidos_17 <- select(partidos_17,
c("Date", "HomeTeam", "FTHG", "AwayTeam", "FTAG"))
partidos_18 <- select(partidos_18,
c("Date", "HomeTeam", "FTHG", "AwayTeam", "FTAG"))
partidos_19 <- select(partidos_19,
c("Date", "HomeTeam", "FTHG", "AwayTeam", "FTAG"))
# La función mutate cambia el formato de dato del campo que se deseé. En este
# caso el campo "date".
partidos_17 <- mutate(partidos_17,
Date=as.Date(Date, "%d/%m/%y"))
partidos_18 <- mutate(partidos_18,
Date=as.Date(Date, "%d/%m/%y"))
partidos_19 <- mutate(partidos_19,
Date=as.Date(Date, "%d/%m/%y"))
# La función do.call() compuesta con las funciones rbind() y list(), une los
# tres dataframes por campo y en orden ascendente en en campo de la fecha.
SmallData <- do.call(rbind, list(partidos_17,
partidos_18,
partidos_19))
# La función rename() permite cambiar el nombre de los campos seleccionados.
SmallData <- rename(SmallData, c("date"="Date",
"home.team" = "HomeTeam",
"home.score"="FTHG",
"away.team"="AwayTeam",
"away.score"="FTAG"))
# Se guarda un archivo .csv del dataframe "SmallData"
write.csv(SmallData, "soccer.csv", row.names = FALSE)
# Se crean los dataframes requeridos con la función create.fbRanks.dataframes()
listasoccer <- create.fbRanks.dataframes(scores.file = "soccer.csv")
# Se guarda el campo "scores" dentro de la variable anotaciones.
anotaciones <- listasoccer[["scores"]]
# La función rank.teams() clasifica a los equipos según tres parámetros, total,
# ataque y defensa
anotaciones <- rank.teams(anotaciones)
# Se guarda el campo "teams" dentro de la variable equipos.
equipos <- listasoccer[["teams"]]
# La función rank.teams() clasifica a los equipos según tres parámetros, total,
# ataque y defensa
equipos <- rank.teams(scores = listasoccer[["scores"]],
teams = equipos)
# La función unique nos permite obtener los datos no repetidos de un campo, en
# este caso "date" dentro de la
fecha <- unique(as.Date(listasoccer[["scores"]]$date))
fecha
# Se obtiene el número de datos en "fecha".
n <- length(fecha)
n
# Se obtiene el ranking de las fechas del dataframe que inicialmente se tenía,
# es decir: 2017-08-18 al 2020-12-22.
ranking <- rank.teams(scores = listasoccer[["scores"]],
teams = listasoccer[["teams"]],
max.date = fecha[n - 1],
min.date = fecha[1])
predict(object = ranking, date = fecha[n])
tail(SmallData)
# Se obtiene el ranking de las fechas del dataframe que inicialmente se tenía,
# es decir: 2017-08-18 al 2020-12-22.
ranking <- rank.teams(scores = listasoccer[["scores"]],
teams = listasoccer[["teams"]],
max.date = fecha[n - 1],
min.date = fecha[1],
date.format = '%d/%m/%Y')
predict(object = ranking, date = fecha[n])
# Se obtiene el ranking de las fechas del dataframe que inicialmente se tenía
# menos la última, es decir: 2017-08-18 al 2020-12-22.
ranking <- rank.teams(scores = listasoccer[["scores"]],
teams = listasoccer[["teams"]],
min.date = fecha[1],
max.date = fecha[n - 1])
# Se pone a prueba el modelo basado en los datos de "ranking" con la última
# fecha del dataset, es decir, la fecha número n
predict(object = ranking, date = fecha[n])
# Se pone a prueba el modelo basado en los datos de "ranking" con la última
# fecha del dataset, es decir, la fecha número n. Esto
predict(model = randomForest,object = ranking, date = fecha[n])
# Se pone a prueba el modelo basado en los datos de "ranking" con la última
# fecha del dataset, es decir, la fecha número n. Esto
predict(model,object = ranking, date = fecha[n])
# Se pone a prueba el modelo basado en los datos de "ranking" con la última
# fecha del dataset, es decir, la fecha número n. Esto
predict(model="randomForest",object = ranking, date = fecha[n])
# Se pone a prueba el modelo basado en los datos de "ranking" con la última
# fecha del dataset, es decir, la fecha número n. Esto
predict(model="gam",object = ranking, date = fecha[n])
# Se pone a prueba el modelo basado en los datos de "ranking" con la última
# fecha del dataset, es decir, la fecha número n. Esto
predict(object = ranking, date = fecha[n])
# Se pone a prueba el modelo basado en los datos de "ranking" con la última
# fecha del dataset, es decir, la fecha número n. Esto
predict(object = ranking, date = fecha[n])
runApp('~/BEDU/data-leagues-team-5/PostWork-8')
dir()
dir()
runApp('~/BEDU/data-leagues-team-5/PostWork-8')
partidos_liga_española_df <- read.csv("https://www.football-data.co.uk/mmz4281/1920/SP1.csv")
casa <- partidos_liga_española_df$FTHG
(visitante <- partidos_liga_española_df$FTAG)
(goles <- as.data.frame(cbind(casa, visitante)))
(total_de_partidos <- length(casa))
library(dplyr)
(matriz_goles <- table(goles))
(frecuencia_goles_casa <- rowSums(matriz_goles))
(frecuencia_goles_visitante <- colSums(matriz_goles))
(probabilidad_goles_casa <- c(frecuencia_goles_casa / total_de_partidos))
(probabilidad_goles_visitante <- c(frecuencia_goles_visitante / total_de_partidos))
(frecuencia_goles_casa <- rowSums(matriz_goles))
(matriz_goles <- table(goles))
